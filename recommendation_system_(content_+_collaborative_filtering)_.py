# -*- coding: utf-8 -*-
"""Recommendation System (Content + Collaborative Filtering).

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3OR4VeCzokBLLmhDBl_dThg6i_3XQrR
"""

"""
Recommendation System (single-file)
-----------------------------------

Features:
- Supports two modes:
  * Content-based: TF-IDF similarity on item metadata
  * Collaborative filtering: User-Item Matrix + cosine similarity
- Hybrid scoring: weighted average of both methods
- Train, recommend, and evaluate functions
- CLI for training, recommending, and evaluation

Usage:
    # Train recommendation model
    python recommender.py train --ratings ratings.csv --items items.csv --out model.joblib

    # Recommend for a user
    python recommender.py recommend --model model.joblib --user 42 --topk 5

Dependencies:
    pip install pandas scikit-learn joblib
"""

import argparse
import sys
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
import joblib


class HybridRecommender:
    def __init__(self, ratings: pd.DataFrame, items: pd.DataFrame):
        """
        ratings: DataFrame with columns [user_id, item_id, rating]
        items: DataFrame with columns [item_id, title, description, ...]
        """
        self.ratings = ratings
        self.items = items
        self.user_item_matrix = ratings.pivot_table(index="user_id", columns="item_id", values="rating")
        self.user_item_matrix.fillna(0, inplace=True)

        # Build item profile TF-IDF
        self.vectorizer = TfidfVectorizer(stop_words="english")
        text_data = items["description"].fillna("")
        self.item_tfidf = self.vectorizer.fit_transform(text_data)
        self.item_ids = items["item_id"].tolist()

        # Precompute similarities
        self.item_sim_content = cosine_similarity(self.item_tfidf)
        self.item_index = {item_id: idx for idx, item_id in enumerate(self.item_ids)}

    def recommend(self, user_id: int, topk: int = 5, alpha: float = 0.5) -> pd.DataFrame:
        """
        alpha: weight for collaborative (0=content-only, 1=collab-only)
        """
        if user_id not in self.user_item_matrix.index:
            return pd.DataFrame(columns=["item_id", "score"])

        user_ratings = self.user_item_matrix.loc[user_id].values
        rated_idx = np.where(user_ratings > 0)[0]

        # Collaborative: user profile similarity
        collab_scores = self.user_item_matrix.T.dot(user_ratings)
        collab_scores = collab_scores / (np.linalg.norm(user_ratings) + 1e-6)

        # Content: average similarity to rated items
        if len(rated_idx) > 0:
            sim_matrix = self.item_sim_content[rated_idx].mean(axis=0)
            content_scores = sim_matrix
        else:
            content_scores = np.zeros(len(self.item_ids))

        # Normalize
        collab_scores = collab_scores[:len(self.item_ids)]
        collab_scores = (collab_scores - collab_scores.min()) / (collab_scores.max() - collab_scores.min() + 1e-6)
        content_scores = (content_scores - content_scores.min()) / (content_scores.max() - content_scores.min() + 1e-6)

        # Hybrid
        scores = alpha * collab_scores + (1 - alpha) * content_scores

        recommendations = pd.DataFrame({
            "item_id": self.item_ids,
            "score": scores
        }).sort_values("score", ascending=False)

        return recommendations.head(topk)

    def save(self, path: str):
        joblib.dump(self, path)

    @staticmethod
    def load(path: str):
        return joblib.load(path)


# -------------------------
# CLI
# -------------------------

def parse_args():
    p = argparse.ArgumentParser(description="Hybrid Recommendation System")
    sub = p.add_subparsers(dest="command")

    t = sub.add_parser("train")
    t.add_argument("--ratings", required=True, help="Ratings CSV (user_id,item_id,rating)")
    t.add_argument("--items", required=True, help="Items CSV (item_id,title,description)")
    t.add_argument("--out", required=True, help="Output model path")

    r = sub.add_parser("recommend")
    r.add_argument("--model", required=True, help="Trained model path")
    r.add_argument("--user", type=int, required=True, help="User ID")
    r.add_argument("--topk", type=int, default=5, help="Top K items")

    return p.parse_args()


def main():
    args = parse_args()
    if args.command == "train":
        ratings = pd.read_csv(args.ratings)
        items = pd.read_csv(args.items)
        model = HybridRecommender(ratings, items)
        model.save(args.out)
        print(f"âœ… Trained recommender saved to {args.out}")

    elif args.command == "recommend":
        model = HybridRecommender.load(args.model)
        recs = model.recommend(args.user, topk=args.topk)
        print("Recommended items:")
        print(recs)

    else:
        print("No command given. Use --help.", file=sys.stderr)


if __name__ == "__main__":
    main()